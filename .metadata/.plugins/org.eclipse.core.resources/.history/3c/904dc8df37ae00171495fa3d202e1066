import java.io.BufferedReader;
import java.io.BufferedWriter;

import java.io.FileReader;
import java.io.FileWriter;
import java.util.List;

public class homework2 {
	
	
	/*
	 * matrix means the input 
	 * valueMatrix store the value in each cell
	 * */
	char[][] matrix=null;
	char[][] outputMatrix=null;
	int[][] valueMatrix=null;
	String filename="input.txt";
	
	int Width;
	int NumberOfTypes;
	float times;
	
	int nextCol;
	int nextRow;

	public homework2(){
		
	}
	public static void main(String[] args){
		 homework2 hw=new homework2();
			hw.parseInput();
			hw.runAlgorithm();
		    hw.generateOutput();
	}
	
	//parse the input file
	public void parseInput(){
		try{
			BufferedReader input=new BufferedReader(new FileReader(filename));
			Width=Integer.parseInt(input.readLine());
			NumberOfTypes=Integer.parseInt(input.readLine());
			times=Float.parseFloat(input.readLine());
			matrix=new char[Width][Width];
			outputMatrix=new char[Width][Width];
		    valueMatrix=new int[Width][Width];
			String line="";
			int index=0;
			while((line=input.readLine())!=null){
				for(int i=0;i<Width;i++){		
					matrix[index][i]=line.charAt(i);
				}
				index++;
			}
			input.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		
	}
	
	//generate the output file
	public void generateOutput(){
		try{
			BufferedWriter output=new BufferedWriter(new FileWriter("output.txt"));
			    char col=(char)(nextCol+'a');
			    output.write(col+""+nextRow+"\n");
				for(int i=0;i<Width;i++){
					String temp=new String(outputMatrix[i]);
					output.write(temp+"\n");
				}
			
			
			output.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
		
	}
	
	public void runAlgorithm(){
		info result=minimax(0,1,matrix,new info(-1,-1,0));
	}
	
	/*
	 * role ==0 for other role ==1 for me
	 * depth <=3
	 * */
	public class info{
		public int MoveRow;
		public int MoveCol;
		public int Score;
		public info(int r,int c,int s){
			this.MoveRow=r;
			this.MoveCol=c;
			this.Score=s;
		}
	}
	public info minimax(int depth,int role,char[][] state,info cur){
		//当到达叶子结点深度为3时候不计算直接返回
		if(depth==3||isGameOver(state)==true){
			return cur;
		}
		//保存一开始的state
		char[][] rootState=new char[Width][Width];
		for(int i=0;i<Width;i++){
			for(int j=0;j<Width;j++){
				rootState[i][j]=state[i][j];
			}
		}
		
		
		//当我的turn的时候，希望得到最大的那个结果.
		if(role==1){
			//记录最优info
			info best=new info(cur.MoveRow,cur.MoveCol,Integer.MIN_VALUE);
			//尝试每一个位置
			for(int i=0;i<Width;i++){
				for(int j=0;j<Width;j++){
					if(state[i][j]=='*')continue;
					int score=changeState(i,j,state);
					info item=minimax(depth+1,0,state,new info(i,j,cur.Score+score));
					if(item.Score>best.Score){
						best.MoveRow=i;
						best.MoveCol=j;
						best.Score=item.Score;
					}
					replace(state,rootState);
				}
			}
			return best;
		}
		//当对手的turn的时候，对方希望我的值最小.
		else{
			//记录最优info
			info best=new info(cur.MoveRow,cur.MoveCol,Integer.MAX_VALUE);
			for(int i=0;i<Width;i++){
				for(int j=0;j<Width;j++){
					if(state[i][j]=='*')continue;
					int score=changeState(i,j,state);
					info item=minimax(depth+1,0,state,new info(i,j,cur.Score+score));
					if(item.Score<best.Score){
						best.MoveRow=i;
						best.MoveCol=j;
						best.Score=item.Score;
					}
					replace(state,rootState);
				}
			}
			return best;
		}
		
	}
	
	private boolean isGameOver(char[][] state) {
		// TODO Auto-generated method stub
		for(int i=0;i<Width;i++){
			for(int j=0;j<Width;j++){
				if(state[i][j]!='*')return false;
			}
		}
		return true;
	}
	private void replace(char[][] state, char[][] rootState) {
		// TODO Auto-generated method stub
		
	}
	//实现更改棋盘并且返回更改操作所产生的新得分
	public int changeState(int i, int j, char[][] state) {
		// TODO Auto-generated method stub
		return 0;
	}

}
